<!--
layout: default
-->
<h1>Block: {{ name }}</h1>
<svg width="800px" height="600px" style="border: 1px solid black;">
    <style type="text/css">
        text {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }
        .block-square {
            stroke: black;
            fill: white;
            filter: drop-shadow(0 3px 5px rgba(0,0,0,0.3));
        }
        .dot {
            stroke: black;
            fill: black;
        }
        .block-input-dot.external-dot, .block-output-dot.dot-on-box {
            fill: white;
        }
        path {
            stroke: black;
        }
        path.block-input-path, path.block-output-path {
            fill: transparent;
        }
        rect.output-field {
            stroke-dasharray: 5;
        }
    </style>
    <g id="renderspace"></g>
</svg>
<script>
    let inputHeight = 100;

    let block = cryptoflow.blocks["{{ id }}"];
    block.inputs = block.inputs.map(inputName => {
        return { name: inputName, value: "example" };
    })

    let renderspace = d3.select("#renderspace");

    // render block
    // - bounding group
    let mainBlockX = 300;
    let mainBlockY = 200;

    // - square
    let renderedBlock = renderspace.append("g")
            .attr("class", "block")
            .attr("cursor", "pointer")
            .attr("transform", `translate(${mainBlockX}, ${mainBlockY})`);

    let squareDimensions = { width: 100, height: 50 };

    let blockSquare = renderedBlock.append("rect")
        .attr("class", "block-square")
        .attr("width", squareDimensions.width)
        .attr("height", squareDimensions.height);

    renderedBlock.on("click", () => {
        alert("xor is made up of:\n\n" + block.innards.toString());
    });
    
    // - text in square
    let blockText = renderedBlock.append("text")
        .attr("class", "block-label label")
        .text(block.name);

    let textDimensions = blockText.node().getBBox();

    blockText
        .attr("x", (squareDimensions.width / 2) - (textDimensions.width / 2))
        .attr("y", (squareDimensions.height / 2) + (textDimensions.height / 6));

    // render inputs
    let input = renderspace.selectAll("g.block-input")
            .data(block.inputs)
        .enter().append("g")
            .attr("class", "block-input")
            .attr("transform", (d, i) => `translate(0, ${i*inputHeight})`);
    
    // - path
    let getRelativeBlockY = (i) => mainBlockY - (i * inputHeight);
    let getInputDotOnBlockY = (i) => getRelativeBlockY(i) + i * 15 + 10;

    input.append("path")
        .attr("class", "block-input-path path-between-circles")
        .attr("d", (d, i) => `M225 20 C250 20, 275 ${getInputDotOnBlockY(i)}, 300 ${getInputDotOnBlockY(i)}`);

    // - editable field
    let inputEditable = input.append("g")
        .attr("transform", "translate(50, 10)")
        .attr("cursor", "pointer");

    inputEditable
        .append("rect")
            .attr("stroke", "black")
            .attr("fill", "white")
            .attr("width", 175)
            .attr("height", 20);

    let inputEditableText = inputEditable.append("text")
            .text((d) => d.value)
            .attr("font-size", "0.8em");
    
    let inputEditableTextDimensions = inputEditableText.node().getBBox();

    inputEditableText
            .attr("x", 3)
            .attr("y", (inputEditableTextDimensions.height / 6) * 5);

    inputEditable.on("click", (d) => {
        let v = d.value;
        let bytes = stringToByteArray(d.value);
        let hex = byteArrayToHex(bytes);
        alert(`input:\nstr:${d.value}\nhex:${hex}`);
    });

    // - label
    let inputLabel = input.append("text")
        .attr("class", "block-input-label label")
        .text((d) => d.name);
    
    let inputLabelDimensions = inputLabel.node().getBBox();

    inputLabel
        .attr("x", 50 - 5 - inputLabelDimensions.width)
        .attr("y", inputLabelDimensions.height);

    // - dots
    input.append("circle")
        .attr("class", "dot block-input-dot dot-on-box")
        .attr("r", 4)
        .attr("cx", 300)
        .attr("cy", (d, i) => getInputDotOnBlockY(i));

    input.append("circle")
        .attr("class", "dot block-input-dot external-dot")
        .attr("r", 4)
        .attr("cx", 225)
        .attr("cy", 20);

    // render outputs
    let output = renderspace.append("g")
        .attr("class", "block-output")
        .attr("transform", "translate(400, 200)");

    output.append("path")
        .attr("class", "block-output-path path-between-circles")
        .attr("d", "M0 25 L75 25");
    
    output.append("circle")
        .attr("class", "dot block-output-dot dot-on-box")
        .attr("r", 4)
        .attr("cy", 25);
    
    output.append("circle")
        .attr("class", "dot block-output-dot external-dot")
        .attr("r", 4)
        .attr("cx", 75)
        .attr("cy", 25);

    let outputEditable = output.append("g")
        .attr("transform", "translate(75,15)")
        .attr("cursor", "pointer");

    outputEditable.append("rect")
        .attr("class", "output-field")
        .attr("width", 175)
        .attr("height", 20)
        .attr("stroke", "black")
        .attr("fill", "transparent");

    let outputEditableText = outputEditable.append("text")
        .text("loading...")
        .attr("font-size", "0.8em");

    let outputEditableTextDimensions = outputEditableText.node().getBBox();

    outputEditableText
        .attr("x", "7")
        .attr("y", (inputEditableTextDimensions.height / 6) * 5);

    outputEditable.on("click", () => alert("output:\n" + outputEditable.text()));

    // - label
    let outputLabel = output.append("text")
        .text("output (in hex)");

    let outputLabelDimensions = outputLabel.node().getBBox();

    outputLabel
        .attr("x", 75 + 175 + 5)
        .attr("y", 10 + (outputLabelDimensions.height / 6) * 5);

    doCalculation();

    async function doCalculation() {
        let inputValues = block.inputs
            .map((input) => stringToByteArray(input.value));
        console.log("input values", inputValues);
        let inputValuePairs = pairInputValues(inputValues);
        console.log("input value pairs", inputValuePairs);
        let outputValues = await Promise.all(inputValuePairs
            .map((inputValuePair) => { return block.innards.apply(null, inputValuePair); }));
        console.log("output values", outputValues);
        let result = byteArrayToHex(outputValues);
        console.log("result", result);
        outputEditableText.text(result);
        return result;
    }

    function stringToByteArray(str) {
        return str.split("").map((c) => c.charCodeAt());
    }

    // basically a zip with x input value arrays
    function pairInputValues(inputValues) {
        let len = Math.max.apply(null, inputValues.map(inputValue => inputValue.length));
        let inputValuePairs = [];
        for(let i = 0; i < len; i++) {
            inputValuePairs.push(inputValues.map((inputValue) => {
                return inputValue[i] || [];
            }));
        }
        return inputValuePairs;
    }

    function byteArrayToHex(byteArray) {
        return byteArray
            .map(i => i.toString(16))
            .map(h => { if(h.length < 2) return "0" + h; else return h; })
            .join("");
    }

    function byteArrayToString(byteArray) {
        return byteArray.map(String.fromCharCode).join("");
    }

    //TODO: connect each input to an editable field
    //TODO: connect output to a text field
</script>
